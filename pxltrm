#!/usr/bin/env bash
#
# pxltrm - A pixel art editor for the terminal.


clear_screen() {
    printf '\e[?7l\e[2J\e[2;1H\e[0m'
    history+=('\e[2;0H')
}

get_term_size() {
    shopt -s checkwinsize; (:;:)

    [[ -z "$LINES" || -z "$COLUMNS" ]] && \
        read -r LINES COLUMNS < <(stty size)
}

print_palette() {
    for i in {1..8}; do
        [[ "$i" == "$color" ]] && block_char="▃" || block_char=" "
        status+="\\e[48;5;${i}m\\e[30m${block_width// /${block_char}}\\e[0m"
    done
}

status_line() {
    local status

    # Generate block width based on terminal width.
    printf -v block_width "%$((COLUMNS / 24))s" ""
    printf -v padding "%b" "\\e[$((COLUMNS - COLUMNS / 3))C"

    print_palette
    print_color

    # Top status bar.
    hud="[d]raw, [e]rase, clea[r], [s]ave, [o]pen, e[x]it "
    hud="${hud//\[/\[\\e[1m}"
    printf '\e[s\e[0;0H\e[0m%b' "${hud//\]/\\e[0m\]}"

    # Bottom status bar.
    printf '\e[%s;0H\e[0m%b\e[0m, %b\e[0m\e[99999D%b\e[1A\e[%sD%b\e[u' \
           "$((LINES-2))" \
           "[\\e[1mc\\e[0m]olor: ${print_col}${color}" \
           "[\\e[1mb\\e[0m]rush: \\e[1m${brush_char:=█}" \
           "${padding}${status}" \
           "$COLUMNS" \
           "${padding}${status//▃/ }"
}

status_line_clean() {
    printf '%b' "\\e[s\\e[$((LINES-3));0H\\e[0J\\e[u"
}

save_file() {
    [[ -z "$1" ]] && return
    printf '%s' "${history[@]}" > "$1"
    printf '\e[%s;0H%s' "$((LINES-1))" "File saved in $1"
}

load_file() {
    clear_screen
    load_file="$1"
    printf '%b' "\\e[2;0H$(<"$1")\\e[2;0H"
    history=("$_" "${history[@]}")
    status_line
}

hex_to_rgb() {
    ((r=16#${color:1:2}))
    ((g=16#${color:3:2}))
    ((b=16#${color:5:6}))
}

print_color() {
    case "${color:=7}" in
        "#"*) hex_to_rgb;: "\\x1b[38;2;${r};${g};${b}m" ;;
        [0-9]*):           "\\e[38;5;${color}m" ;;
        *):                "\\e[38;5;7m"
    esac
    printf -v print_col '%b' "\\e[1m$_"
    history+=("$_")
}

prompt() {
    printf '\e[s\e[%s;0H\e[0m' "$((LINES-1))"

    case "$1" in
        s) read -rp "save file: " file; save_file "${file:-$load_file}" ;;
        o) read -rp "load file: " file; [[ -f "$file" ]] && load_file "$file" ;;
        c) read -rp "input color: " color ;;
        b) read -rp "input brush: " brush_char ;;
    esac

    printf '\e[u'
    status_line_clean
    status_line
}

cursor() {
    case "${1: -1}" in
        # Cursor Movement.
        A|k): '\e[1A' ;;
        B|j): '\e[1B' ;;
        C|l): '\e[1C' ;;
        D|h): '\e[1D' ;;

        # Line movement.
        H): '\e[999999D' ;;
        L): '\e[999999C' ;;

        # Color Selection.
        [1-8]) color="${1: -1}";  status_line; return ;;
        c)     prompt "${1: -1}"; status_line; return ;;

        # Drawing Cells.
        d) print_color;: "${print_col}${brush_char:=█}" ;;
        e) printf "%${#brush_char}s" "" ;;
        M)
            IFS=\; read -rsa pos <<< "${1/'^['}"
            printf '\e[%sH' "${pos[2]/M};${pos[1]}"
            print_color;: "${print_col}${brush_char:=█}\\e[1D"
        ;;

        # Brushes
        b) prompt "${1: -1}"; status_line; return ;;

        # Saving/Loading
        s|o) prompt "${1: -1}"; return ;;

        # Other.
        r) clear_screen; status_line; return ;;
        x) exit ;;
        *) return ;;
    esac

    printf '%b' "$_"
    history+=("$_")
}

main() {
    clear_screen
    get_term_size
    status_line

    # Enable mouse tracking.
    printf '\e[?1000h\e[?1006h'

    trap 'clear_screen; printf \\e[?7h\\e[?1000l' EXIT
    trap 'status_line_clean; get_term_size; status_line' SIGWINCH

    for ((;;)); { read -p $'\e[38;5;0m' -d "" -t 0.010 -rs key; cursor "$key"; }
}

main "$@"
